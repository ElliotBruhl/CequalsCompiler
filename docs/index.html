<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compiler Information</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header>
        <a href="https://github.com/ElliotBruhl/CequalsCompiler" class="logo-link">
            <img src="CequalsLogo.png" alt="Cequals Logo" class="logo">
        </a>
        <h1 class="title">Cequals Documentation</h1>
        <a href="https://github.com/ElliotBruhl" class="author">
            <span>Elliot Bruhl</span>
        </a>
    </header>
    
    <div class="content">
        <h2 id="table-of-contents">Table of Contents</h2>
        <hr>
        <nav>
            <ul>
                <li><a href="#about">About</a></li>
                <li><a href="#setup">Setup Guide</a>
                    <ul>
                        <li><a href="#tools">Installing Other Tools</a></li>
                        <li><a href="#compiler">Installing the Compiler</a></li>
                        <li><a href="#compiling">Setting Up and Compiling a Project</a></li>
                    </ul>
                </li>
                <li><a href="#language">The Cequals Language</a>
                    <ul>
                        <li><a href="#declaring-main">Declaring main</a></li>
                        <li><a href="#variables">Declaring and Assigning Variables</a>
                            <ul>
                                <li><a href="#math">Math Operations</a></li>
                            </ul>
                        </li>
                        <li><a href="#conditionals">Conditional Statements</a></li>
                        <li><a href="#loops">While Loops</a></li>
                        <li><a href="#functions">Declaring and Calling Functions</a>
                            <ul>
                                <li><a href="#external-functions">Calling External Functions</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="#compiler-details">The Cequals Compiler</a>
                    <ul>
                        <li><a href="#main">Main</a></li>
                        <li><a href="#tokenizer">Tokenizer</a></li>
                        <li><a href="#varTable">varTable/funcTable</a></li>
                        <li><a href="#parser">Parser</a></li>
                        <li><a href="#codeGen">Code Generation</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    
        <h2 id="about">About</h2>
        <hr>
        <p>
            The Cequals language and compiler were made by Elliot Bruhl as a project to learn more about how compilers and 
            computers work at a lower level. The compiler is written in the <a href="https://en.wikipedia.org/wiki/C_(programming_language)"> C programming language</a>
            , and the output is <a href="https://en.wikipedia.org/wiki/X86_assembly_language"> x86 assembly</a>, intended for the Win64 platform. 
        </p>
        <p>
            The Cequals language is not a very practical language, as there are certain important features that are implemented poorly or not at all.
            However, the language does serve as a good learning tool by providing a simple syntax and a literal, annotated assembly output.
        </p>
        <p>
            This project was started in September 2024 and was completed in August 2025. The project was built in a series of phases, each lasting about a month.
            The first month was used to learn C and make the project’s lexer. The next month was used to set up the data
            structures that the AST (Abstract Syntax Tree) would use during the parsing phase.
            The next two months were used for parsing math operations and function calls. The rest of the constructions were parsed in the following month. Learning x86 assembly
            and writing the output code from the AST took another month. The remaining months were used writing the documentation, fixing bugs, and adding more features.
        </p>

        <h2 id="setup">Setup Guide</h2>
        <hr>
        <h3 id="tools">Installing Other Tools</h3>
        <p>
            To compile and run Cequals programs, you must install these two tools:
        </p>
        <ul>
            <li><a href="https://www.nasm.us/">NASM</a> - Assembler for x86 assembly code.</li>
            <li><a href="https://gcc.gnu.org/">GCC</a> - Compiler for linking the assembly code into an executable.</li>
        </ul>
        <p>
            Ensure that both are installed and added to your system's PATH. Verify the installation by running <code>gcc -v</code> and <code>nasm -v</code> in your command prompt.
        </p>
        <h3 id="compiler">Installing the Compiler</h3>
        <p>
            The Cequals compiler is available as a pre-compiled executable. You can download it from <a href="https://github.com/ElliotBruhl/CequalsCompiler/tree/main/binaries">this folder</a> on GitHub.
            Alternatively, you can compile it from the source code that is available at <a href="https://github.com/ElliotBruhl/CequalsCompiler/tree/main/src">this folder</a> on GitHub.
        </p>

        <h3 id="compiling">Setting Up and Compiling a Project</h3>
        <p>
            To set up a Cequals project, create a folder containing the Cequals compiler executable, an input file (e.g., <code>setupTest.ceq</code>), and an output file (e.g., <code>setupTest.asm</code>).
            Write your Cequals code in the input file. As an example, you can use the following code:
            <pre><code>     func main() {
        return 0;
    }</code></pre>
            To compile and run the project, open a command prompt in the project folder and run the following commands:
            <ul>
                <li><code>cequals.exe setupTest.ceq setupTest.asm</code> to compile the code,</li>
                <li><code>nasm -f win64 setupTest.asm -o setupTest.obj</code> to assemble the code,</li>
                <li><code>gcc setupTest.obj -o setupTest.exe</code> to link the code,</li>
                <li><code>setupTest.exe</code> to run the executable, and finally</li>
                <li><code>echo return value: %ERRORLEVEL%</code> to print the return value and verify that it matches the value in the input file.</li>
            </ul>
        </p>
        
        <h2 id="language">The Cequals Language</h2>
        <hr>
        <h3 id="declaring-main">Declaring main</h3>

        <h3 id="variables">Declaring and Assigning Variables</h3>
        <h4 id="math">Math Operations</h4>

        <h3 id="conditionals">Conditional Statements</h3>

        <h3 id="loops">While Loops</h3>

        <h3 id="functions">Declaring and Calling Functions</h3>
        <h4 id="external-functions">Calling External Functions</h4>

        <h2 id="compiler-details">The Cequals Compiler</h2>
        <hr>

        <h3 id="main">Main</h3>

        <h3 id="tokenizer">Tokenizer</h3>

        <h3 id="varTable">varTable/funcTable</h3>

        <h3 id="parser">Parser</h3>

        <h3 id="codeGen">Code Generation</h3>

    </div>

    <footer>
        <p>&copy; 2025 <a href="https://github.com/ElliotBruhl">Elliot Bruhl</a>. All Rights Reserved.
        The <a href="https://github.com/ElliotBruhl/CequalsCompiler" target="_blank" rel="noopener noreferrer">Cequals Compiler</a> 
        is licensed under the <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener noreferrer">MIT License</a>.</p>
    </footer>  
    
    </body>
</html>
<!--
old readme
# Compiler Information

- **Language**: Written in C (version C17 - compatible with C99+)
- **Input**: C= (Cequals) language (documentation here later)
- **Output**: x86-64 Assembly (NASM syntax) for Win64

## How It Works

The compilation process is broken into three main steps:

1. **Tokenization**  
   The input file is read, and a list of tokens is created. Tokens include words, numbers, or symbols that have specific meanings in the language.

2. **Parsing**  
   The tokens are converted into an Abstract Syntax Tree (AST), which is a highly detailed, language-independent representation of the program. This step also detects and reports errors.

3. **Code Generation**  
   The AST is transformed into x86 assembly code and written to the output file.

## How to Use the Compiler (Win64)

1. Download the executable or compile it from the source files
2. Create a folder with the executable, an input file ex. "input.txt", and an output file ex. "output.txt"
3. Write some code in the input file
4. Run the executable using command: {executable name}.exe {input file name}.txt {output file name}.txt {optional arguments like -useLib}
5. Assemble the file using NASM: nasm -f win64 -g output.asm -o output.obj
6. Link the file (must link with the C standard library) using GCC: gcc output.obj -o output.exe -g
7. Run the output executable.

## Exit Codes (`main.c`)

- `0`  – Success
- `-1` – File read failed
- `-2` – Tokenizer failed
- `-3` – Variable symbol table creation failed
- `-4` – Function symbol table creation failed
- `-5` – Parser failed
- `-6` – Assembly generation failed

## The Tokenizer (`tokenizer.c/h`)

The tokenizer stores data in a **doubly linked list** of structs, where each node holds the following information:

- **Line number**
- **Token type**
- **Token value**
- **Previous node**
- **Next node**

### Token Types

1. **Identifiers** – Alphanumeric strings (except keywords).
2. **Numbers** – Whole numbers in the range `-(2^63)` to `(2^63) - 1`.
3. **Operators** – Almost all operators available in C.
4. **Keywords** – Special reserved words in the language.
5. **Separators** – Symbols like `;`, `()`, `{}`, and `,`.

## The Parser (`parser.c/h`)

The parser stores a **doubly linked list** of structs, where each node holds:

- **Sub-node type indicator**
- **Sub-node**
- **Previous node**
- **Next node**

### AST Node Types

Each sub-node is a struct containing the necessary details to generate code later:

- **Variable Declaration** – Holds the variable name.
- **Variable Assignment** – Holds the variable name and new value.
- **Function Declaration** – Holds the function name, argument count, argument names, and function body.
- **While Loop** – Holds the loop condition and body.
- **Conditional** – Holds the condition, `if` body, and optional `else` body.

### Math Operations

Math operations are particularly tricky due to order of operations and mixed operand types. To handle this:

1. Tokens are converted into **ValueNodes**, structs that store operand types (number, variable, or function call).
2. ValueNodes are converted into a **postfix expression**, which eliminates the need for order-of-operations parsing.
3. The postfix expression is then transformed into a **binary tree** of operators and operands.

## Variable Table (`varTable.c/h`)

- Tracks all variable names within a given scope.
- Computes the offset of each variable from the base pointer of the scope.
- Supports **variable shadowing** (name lookups start in the current scope and proceed outward).

## Function Table (`funcTable.c/h`)

- Tracks all function names and their parameters.
- Uses a **single global scope** for functions (no shadowing; duplicate function names overwrite each other).

## Code Generation